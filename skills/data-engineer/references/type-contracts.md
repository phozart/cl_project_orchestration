# Type Contracts Guide

How to generate binding TypeScript contracts that developers MUST use.

---

## Why Type Contracts

Without contracts:
```
DB: user_id (snake_case)
Developer A: userId (camelCase)
Developer B: user_id (snake_case)
Developer C: userID (mixed)
```

With contracts:
```
TYPE-CONTRACTS.ts defines: id (from user_id)
ALL developers use: id
```

---

## Contract File Structure

```typescript
// docs/data/TYPE-CONTRACTS.ts

/**
 * DATABASE TO CODE MAPPING
 * This file is the SINGLE SOURCE OF TRUTH
 * Generated by: data-engineer
 * Used by: fullstack-developer
 */

// ============================================
// ENTITY: User
// DB Table: users
// ============================================

export interface User {
  id: string;           // DB: id (UUID PRIMARY KEY)
  email: string;        // DB: email (VARCHAR NOT NULL UNIQUE)
  passwordHash: string; // DB: password_hash (VARCHAR NOT NULL)
  name: string;         // DB: name (VARCHAR NOT NULL)
  role: UserRole;       // DB: role (VARCHAR CHECK)
  isActive: boolean;    // DB: is_active (BOOLEAN DEFAULT true)
  createdAt: Date;      // DB: created_at (TIMESTAMP)
  updatedAt: Date;      // DB: updated_at (TIMESTAMP)
}

export type UserRole = 'viewer' | 'user' | 'editor' | 'admin' | 'super_admin';

// Field mapping for raw SQL queries
export const UserFields = {
  id: 'id',
  email: 'email',
  passwordHash: 'password_hash',
  name: 'name',
  role: 'role',
  isActive: 'is_active',
  createdAt: 'created_at',
  updatedAt: 'updated_at',
} as const;

// ============================================
// DTOs (Data Transfer Objects)
// ============================================

export interface CreateUserDTO {
  email: string;
  password: string;  // Plain text, becomes passwordHash
  name: string;
  role?: UserRole;   // Optional, defaults to 'user'
}

export interface UpdateUserDTO {
  email?: string;
  name?: string;
  role?: UserRole;
  isActive?: boolean;
}

export interface UserResponse {
  id: string;
  email: string;
  name: string;
  role: UserRole;
  isActive: boolean;
  createdAt: string;  // ISO string for API
  updatedAt: string;  // ISO string for API
  // Note: passwordHash NEVER in response
}
```

---

## Naming Convention Rules

| Database (SQL) | TypeScript | Rule |
|----------------|------------|------|
| snake_case | camelCase | Standard conversion |
| user_id | userId | FK becomes entityId |
| is_active | isActive | Boolean prefix preserved |
| created_at | createdAt | Timestamp suffix preserved |

---

## Required Sections

Every TYPE-CONTRACTS.ts MUST have:

1. **Header comment** with purpose and ownership
2. **Entity interfaces** for each DB table
3. **Field mapping objects** for raw SQL
4. **DTOs** for create/update operations
5. **Response types** for API responses (no sensitive fields)

---

## Validation Checklist

Before handoff:

- [ ] Every DB table has a TypeScript interface
- [ ] Every column documented with DB type comment
- [ ] Field mapping object for raw SQL queries
- [ ] Create DTO with required fields
- [ ] Update DTO with optional fields
- [ ] Response type without sensitive data (passwords, tokens)
- [ ] Enums match CHECK constraints exactly

---

## Developer Usage

Developer MUST:

```typescript
// 1. Import from contracts
import { User, UserFields, CreateUserDTO } from '@/types/contracts';

// 2. Use types for all data
const user: User = await db.findOne(...);

// 3. Use field mapping for raw SQL
const result = await db.query(
  `SELECT ${UserFields.email}, ${UserFields.name} FROM users`
);

// 4. Use DTOs for mutations
async function createUser(dto: CreateUserDTO): Promise<User> {
  // ...
}
```

---

## Contract Update Protocol

When contracts need to change:

1. Developer finds mismatch
2. Developer reports to data-engineer (not patches code)
3. Data-engineer updates TYPE-CONTRACTS.ts
4. Data-engineer updates SCHEMA.sql if needed
5. Developer re-imports updated contracts

**NEVER patch around contract mismatches. Fix the contract.**
